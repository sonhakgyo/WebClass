1. 컬렉션 프레임워크
    - 자바(Java)에서 제공하는 자료구조
    - 데이터를 효율적으로 다루기 위한 클래스들의 집합

    자료구조(Data Structure)
        - 자료들을 저장할 때 효율적인 구조로 저장하는 것(데이터의 구조 : 스택, 큐, 리스트)
        - 스택 : 후입선출(나중에 들어온 데이터가 먼저 나감 예) 엘리베이터 만원)

    컬렉션 프레임워크의 종류
        <Collection 인터페이스를 구현하는 클래스>
            셋 Set
            리스트 List
            큐 Queue
            맵 Map

        # itertor 
            컬렉션 요소에 접근해서 '반복적으로 요소 접근 시' 도움을 주는 객체

        <제공된 메서드>
            add(E e)             : 지정요소(e) 추가
            contains(Object obj) : 객체 obj 존재여부
            isEmpty()            : 컬렉션이 비어있는지 여부
            isIterator()         : 컬렉션의 itertor 반환
            remove(Object obj)   : 객체 obj 제거
            size()               : 요소 개수 반환
    

2. 제네릭(Generic)
    - 클래스가 다룰 객체를 미리 명시하는 기법
    - 의미 : "제네릭 == 일반화" 
    - 예) 택시를 다루던 버스를 다루던 그냥 자동차(일반화)라고 다룬다.
    - 즉, 제네릭은 모든 종류의 타입을 다룰 수 있도록 클래스나 메서드를 타입 매개변수를 이용하여 선언한 기법

    제네릭 사용방법
        - 클래스명 뒤에 <E>, <K>, <V>와 같은 형식으로 사용한다.
        - 단, < > 안에는 구현 시에는 알파벳, 사용 시에는 클래스만 들어갈 수 있다.

    제네릭 사용구간 
        - 제네릭 클래스 : 클래스 뒤에 제네릭 기법 사용
        - 제네릭 메서드 : 메서드 위에 제네릭 기법 사용

    제네릭타입 매개변수(관례적으로 널리 사용되는 타입명은 하나의 대문자 알파벳을 사용한다.)
        E(Element) : 배열이나 집합들의 요소 타입을 지정한다.
        T(Type)    : 변수의 자료형과 같은 타입을 지정한다.
        S, U       : 여러개의 제네릭 기법을 사용할 때 많이 사용한다.
        K(Key)     : 키 타입 지정 시 사용한다.
        V(Value)   : 값 타입 지정 시 사용한다.


- - - - - 


컬렉션 프레임워크2
                1. 셋 Set
                2. 리스트 List

1. 셋 Set
    - 요소들을 집합적으로 모아놓은 자료구조
    - 인터페이스
    - 중복을 허용하지 않는다.
    - 저장 순서가 없다.

    셋(Set)을 구현한 클래스 
        - 해쉬셋 HashSet
        - 트리셋 TreeSet

        [1] 해쉬셋 HashSet
            - Set과 동일하게 중복이 없고, 순서가 없다.
            - 중복된 요소 add() 시에는 집합에 추가되지 않고 false값을 반환한다.

            <생성자>
                HashSet()             : HashSet 클래스의 기본 생성자
                HshSet(Collection c)  : 컬렉션의 요소로 HashSet 객체 생성
                HashSet(int capacity) : capacity 용량을 갖는 객체 생성

        [2] 트리셋 TreeSet
            - Set과 동일하게 중복은 없으나 정렬 기능이 추가된 형태이다.
            - 데이터 추가 시 기준 데이터보다 작다면 기준의 왼쪽에 위치한다.
            - 데이터 추가 시 기준 데이터보다 크다면 기존의 오른쪽에 위치한다.
            - '이진 탐색 트리'의 구조와 같다.


2. 리스트 List
    - 데이터를 일렬로 늘어놓은 구조
    - 인터페이스
    - 중복을 허용한다.
    - 순서가 있다.

    <리스트 인터페이스의 주요 메서드>
        add(int index, E elem) : index 위치에 elem 추가
        get(int index)         : index 위치에 있는 요소 반환
        indexOf(Object o)      : 요소 o가 있는 위치 반환
        listiterator()         : Listiterator() 반환
        remove(int index)      : index 위치 요소 삭제 후 삭제값 반환
        set(int index, E elem) : index 위치 요소를 elem으로 변경

    리스트(List) 인터페이스를 구현한 클래스
        - 어레이리스트 ArrayList
        - 링크드리스트 LinkedList

        [1] 어레이리스트 ArrayList
            - 요소 추가 시 0번 인덱스부터 차례대로 요소를 저장한다.
            - 배열처럼 크기가 정해져 있지 않다. 추가할 수 있다.
            - 배열에서 발전된 형태이다.

        [2] 링크드리스트 LinkedList 
            - 요소들이 서로 논리적으로 연결되어있는 리스트
            - 각 요소가 다음 요소의 주소를 저장한다.


- - - - - 


컬렉션 프레임워크3
                1. 큐 Queue
                2. 스택 Stack

1. 큐 Queue
    - 선입선출(FIFO)의 구조
    - 한 쪽 끝(rear)에서는 삽입이, 다른 쪽(front)에서는 삭제가 일어나는 구조
    - 큐는 인터페이스이므로 사용하려면 '업캐스팅(Upcasting)'이 필요하다.
    - front : 머리, 삭제, 저장된 원소 중에서 첫 번째 원소
    - rear  : 꼬리, 삽입, 저장된 원소 중에서 마지막 원소 

    [큐와 관련된 메서드]
        boolean add(E e)   : 큐에 요소 e 추가
        E element()        : 큐에 제일 상단 요소 반환
        E remove()         : 큐의 최상단 요소를 반환 후 제거

        boolean offer(E e) : 큐에 요소 e를 추가
        E peek()           : 큐에 제일 상단 요소 반환
        E poll()           : 큐의 최상단 요소를 반환 후 제거 

    [큐 사용법]
        1) Queue<Element> queue = new LinkedList<Element>(); - 주로 사용하는 방법이다.
        2) Queue<Element> queue = new Array<Element>();


2. 스택 Stack
    - 후입선출(LIFO)의 구조 : 나중에 들어온 데이터가 먼저 나간다.
    - 한 쪽 끝(top)에서 삽입과 삭제가 '모두' 일어나는 구조
    - 스택은 클래스이기 때문에 바로 필드 사용이 가능하다.
    - Vector의 자식 클래스
    - top : 삽입, 삭제

    [스택과 관련된 메서드]
        E peek()             : top 요소를 반환
        E pop()              : top 요소 제거 후 반환
        E push(E item)       : top에 요소 추가
        int search(Object O) : 요소 O가 있는지 검색해서 위치 반환


- - - - - 


컬렉션 프레임워크4
                    1. 맵 Map
                    2. 해쉬맵 HashMap   

    맵 Map
        - 키를 통해서 값을 참조할 수 있는 구조이다.
        - 인터페이스이기 때문에 사용하려면 업캐스팅(Upcasting)이 필요하다.

    [맵에서 제공하는 메서드]
        V get(Object Key)                   : 해당 Key와 쌍인 값을 반환
        V put(K key, V value)               : 키와 값을 요소로 추가
        V remove(Object Key)                : 이 키를 가진 요소를 제거
        boolean containsKey(Object Key)     : 해당 키가 있는지 여부 반환
        boolean containsValue(Object value) : 해당 값이 있는지 여부 반환
        boolean isEmpty()                   : 맵 객체에 요소가 없으면 true 반환
        Set<Key> keySet()                   : 키들을 Set 형태로 반환
        int size()                          : 전체 요소의 개수를 반환

    맵 Map을 구현한 대표 클래스
                            - 해쉬맵 HashMap
                            - 트리맵 TreeMap

        [1] 해쉬맵 HashMap 
            - HashMap<String, String> 컬렉션
            - Key와 Value 값으로 데이터를 저장하는 형태
            - Map 인터페이스의 한 종류
            - Map의 모든 속성을 갖고 있으며 저장 방식은 동일하다.
            - '해싱(Hashing)'이라는 검색 알고리즘을 사용한다.
            - Key의 중복은 허용하지 않으나 Value의 중복은 허용한다.

        해싱(Hashing)이란?
            · 메모리 낭비를 최소화하기 위해 저장할 값을 입력받을 시 연산(Hash Function)을 통해 
              해시 테이블에 새로운 주소 값을 생성하여 메모리에 저장(맵핑 Mapping)하는 기법이다.
            · 입력개수 < 입력최댓값일 때는 메모리 낭비가 심하다는 단점이 발생한다.
            · 찾을 값(Key)을 갖고 저장된 위치를 알 수 있고 메모리 낭비를 최소화해주는 것이 '해싱'이다.

# 알고리즘      : 문제를 해걸하기 위한 절차적 해결 과정
# 검색 알고리즘 : 자료구조 내의 데이터 중 원하는 데이터를 찾는 과정
# 배열에 저장된 데이터를 가장 빨리 찾는 방법 
    - 저장된 데이터가 몇 번째 위치하는지를 알아오는 것이다.
    - 데이터를 넣을 때 '데이터 값'을 '위치 값'으로 하면 가장 빠르게 데이터를 찾을 수 있다.

        해싱의 구조 
            - 키 값을 해시 값으로 변경해주는 '해시 함수'
            - 변경된 해시 값으로 저장할 공간인 '해시 테이블'
        

/* 고객관리 프로그램 */
// HashMap을 활용하여 사용자의 이름과 전화번호를 저장하는 전화번호부 만들기

/* 전화번호부 기능 */
// 1. 고객 저장
// 2. 고객 검색
// 3. 전체 보기
// 4. 끝내기

/* HashMap 메서드 정리 */
// 1. 생성         : HashMap 객체명 = new HashMap();
// 2. 삽입         : 객체명.put(Key, Value);
// 3. 가져오기     : 객체명.get(key);
// 4. Key 존재확인 : 객체명.containsKey(Key);


- - - - - 


정렬 Sort 
        1. 선택 정렬 Selection Sort
        2. 삽입 정렬 Insertion Sort
        3. 버블 정렬 Bubble Sort

# 알고리즘      : 문제를 해결하기 위한 절차적 해결 과정
# 정렬 알고리즘 : 데이터를 순서대로 나열하기 위한 절차적인 과정 

1. 선택 정렬 
    - 최소값 혹은 최대값을 선택해서 가장 앞에 위치하여 선택할 위치를 이동하며 정렬하는 방법
    - 장점 : 구현이 쉽다.
    - 단점 : 다른 정렬에 비해 시간이 오래 걸린다.
    - 기본 로직
        1) 정렬되지 않은 인덱스의 맨앞에서부터 이를 포함한 그 이후의 값 중 가장 작은 값을 찾는다.
        2) 가장 작은 값을 찾으면 그 값을 현재 인덱스의 값과 바꿔준다.
            ar[min] = ar[i]
        3) 다음 인덱스로 이동하여 위 과정을 반복한다.
    - 시간 복잡도 : O(n²)

2. 삽입 정렬 
    0) 현재 위치 : i=1, 비교 위치 : j=i-1
    1) 삽입 정렬은 두 번째 INDEX[i = 1]부터 시작한다. 
    2) 현재 INDEX 별도의 변수에 저장한다.
    3) 비교 INDEX = 현재 INDEX-1
    4) INDEX 값 < 비교 INDEX 값
    5) INDEX > 비교 INDEX 값 : 비교 INDEX--

3. 버블 정렬 
    - 인접한 두 수를 비교하여 큰 수를 뒤로 보내는 알고리즘이다.
    - 정렬 과정이 거품이 일어나는 것과 비슷하다하여 버블이라고 한다.
    - 장점 : 구현이 쉽고 코드가 직관적이다.
    - 단점 : 시간이 오래 걸린다.
             최선, 최악, 평균 모두 O(n²)이라는 시간복잡도를 가진다.

